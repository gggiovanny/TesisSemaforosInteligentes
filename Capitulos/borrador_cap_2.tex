
\chapter{Marco teórico} % con la palabra capitulo
\graphicspath{{./../imagenes/}}
\linespread{1.3}
\hypertarget{propuesta-de-arquitectura}{%
\section{Propuesta de Arquitectura}\label{propuesta-de-arquitectura}}

\includegraphics[width=\textwidth]{arquitectura.png} Fig. 1:
Arquitectura de un agente de control.

\hypertarget{truxe1fico}{%
\subsection{Tráfico}\label{truxe1fico}}

Los vehículos que se mueven en los carriles de la intersección y cruzan
de un carril a otro en nodos llamados intersecciones. Sobre las
intersecciónes puede haber ubicados semáforos.

\hypertarget{propiedades-de-la-intersecciuxf3n}{%
\subsection{Propiedades de la
intersección}\label{propiedades-de-la-intersecciuxf3n}}

Son las propiedades intrínsecas de la intersección que no suelen cambiar
con el paso del tiempo:

\begin{itemize}
\tightlist
\item
  Número de calles.
\item
  Carriles en cada calle.
\item
  Extensión aproximada de cada carril.
\item
  Estructura de la intersección: todas las posibles conexiones entre
  carriles.
\item
  Derechos y prioridades de paso.
\item
  Disposición de las luces del semáforo (cuántas hay y a que
  intersección apuntan).
\item
  Existencia de cruces y puentes peatonales, y si tienen algún botón que
  permita detener el tráfico.
\end{itemize}

\hypertarget{observador-de-eventos}{%
\subsection{Observador de eventos}\label{observador-de-eventos}}

Su única tarea es ser el sentido de la vista del agente de control.
Tiene funciones para observar eventos de interés que suceden con
regularidad en el mundo real en un momento dado y sus propiedades, tales
como:

\begin{itemize}
\tightlist
\item
  El paso de los vehículos, con propiedades como:

  \begin{itemize}
  \tightlist
  \item
    Ruta que toma (pueden seguir derecho o girar en algún sentido).
  \item
    Velocidad promedio aproximada.
  \item
    Cuanto tiempo permanece detenido.
  \item
    Aceleración aproximada.
  \end{itemize}
\item
  Cambios de luces (en que carril y a que color cambió).
\end{itemize}

Y también notifica eventos emergentes y sus propiedades, como:

\begin{itemize}
\tightlist
\item
  Aparición de un vehículos de prioridad (de que tipo y en que carril).
\item
  Un accidente (que carril obstruye).
\end{itemize}

Todo lo observado lo comunica al \emph{Registrador de eventos} indicando
el tiempo exacto en el que sucedió (\emph{timestamp}).

\hypertarget{registrador-de-eventos}{%
\subsection{Registrador de eventos}\label{registrador-de-eventos}}

Es el encargado de guardar un caché de los datos crudos enviados por el
\emph{Observador de eventos} e interpretarlos, para cada hora generar
reportes con datos derivados que se almacenan en la base de datos. El
reporte generado agrupa los datos por ciclo de semáforo, siendo éstos
los siguientes:

\begin{itemize}
\tightlist
\item
  Flujo por carril, es decir, el número de vehículos que pasan por cada
  carril cada determinado tiempo.
\item
  Tiempo de espera promedio por carril.
\item
  Densidad de cada carril.
\item
  Cola más larga en la señal roja.
\item
  Número de vehículos que pasan en señal verde.
\item
  Tiempo ocioso de la señal verde.
\item
  Cola más larga próxima fase.
\item
  Tiempo de cambio de la cola más larga en señal roja.
\end{itemize}

También recibe datos al exterior a través de la \emph{Interfaz de
comunicación}, que se almacenan selectivamente en la base de datos.

\hypertarget{interfaz-de-comunicaciuxf3n}{%
\subsection{Interfaz de
comunicación}\label{interfaz-de-comunicaciuxf3n}}

Permite enviar y recibir reportes de otros agentes de control, así como
notificaciones de eventos externos que pueden alterar el tráfico, como:

\begin{itemize}
\tightlist
\item
  Alertas de desastre natural.
\item
  Eventos públicos y días festivos.
\item
  Manifestaciones.
\end{itemize}

\hypertarget{comparador}{%
\subsection{Comparador}\label{comparador}}

Se encarga de comparar constantemente el comportamiento de los eventos
registrados con el comportamiento predicho. Cuando estos difieren de
manera significativa, el comparador solicita al \emph{Modelo predictivo}
que genere una nueva predicción. También se encarga de solicitar nuevas
predicciones cada que un evento externo lo solicite.

\hypertarget{modelo-predictivo}{%
\subsection{Modelo predictivo}\label{modelo-predictivo}}

Se alimenta del histórico de reportes generados por el \emph{Registrador
de eventos} que obtiene de la base de datos para predecir del
comportamiento de una intersección durante la siguiente hora. Los datos
que genera son los mismos que figuran el los reportes creados por el
\emph{Registrador de eventos}. También hace predicciones bajo demanda
cuando el \emph{Comparador} lo solicita.

\textbf{(Incluir aquí gráfica que represente el rango de tiempo en el
que son válidas las predicciones, la estimación de pérdida de tiempo
efectivo por el tiempo de generación, etc.)}

Ya que el proceso de hacer una predicción y su posterior optimización es
un proceso intensivo, las peticiones para nuevas predicciones suceden
cada hora, pero de manera escalonada. Por ejemplo: si existen 4 agentes
de control, uno iniciará una petición de predicción a las 2:00 p.m.,
mientras que otra los hará a las 2:15 p.m., otro a las 2:30, y así
sucesivamente, de tal manera que el tiempo entre cada hora se se reparta
lo más igualitariamente posible. De la mano con estas peticiones
escalonadas, las peticiones se realizarán de manera asíncrona usando
hilos de procesamiento para lograr paralelizar el procesamiento de
varias intersecciones a la vez de ser necesario. De esta manera, se
aprovecha también el sistema de encolamiento de hilos nativo de los
sistemas operativos, que resulta particularmente útil para no atrasar
las predicciones programadas por las realizadas bajo demanda.

\hypertarget{categorizador-de-paruxe1metros}{%
\subsection{Categorizador de
parámetros}\label{categorizador-de-paruxe1metros}}

Se encarga de categorizar la influencia de los parámetro predichos entre
sí mismos y como finalmente influyen sobre el comportamiento global del
tráfico, para así obtener conclusiones en forma de restricciones y
reglas aplicadas para al temporizado de los ciclos del semáforo.
Categoriza intervalos de tiempo que presentan una serie de condiciones a
términos abstractos, como: ``hora pico'', ``hora sin actividad'' o
``tráfico esporádico'', para así poder usar esas categorías como
condiciones para las reglas y restricciones vistas anteriormente.
Categoriza como ventajoso o perjudicial el incremento o decremento de un
parámetro respecto a parámetros que se busquen incrementar o decrementar
(como el tiempo de espera, la generación de colas, etc). De ser
necesario, infiere una función de como su variación afecta a estos
parámetros.

Ejemplo verbal: si se hacen ciclos en verde un un carril \textbf{mayores
a} 45 segundos durante \textbf{horas pico}, se genera una \textbf{cola
de espera perjudicial a la fluidez} del carril perpendicular, entonces
se infiere una regla que impida que se rebase ese tiempo de ciclo dadas
esas condiciones, y en caso de que se tenga que se rebase, se tenga la
función que indica que tanto perjudica ese aumento para calcular los
tiempos de ciclo que produzcan el mejor costo-beneficio (pues se tienen
que tomar en cuenta el resto de los parámetros).

Este módulo analiza constantemente los reportes almacenados en la base
de datos para realizar el proceso mencionado anteriormente y todo lo
inferido se guarda de manera centralizada como una base de conocimientos
central como registros en la base de datos.

Este módulo se inspiro en la llamada \emph{Colección de hechos} usada en
\textcite{JoelTrejo2006}.

\begin{quote}
La colección de hechos alberga los datos correspondientes a la
aplicación de determinada estrategia de control cuando se presentan
ciertas condiciones en el tráfico observado. La colección de hechos
puede desempeñar el papel de memoria auxiliar en la cual se registran
los razonamientos llevados a cabo. \textcite[p. 47]{JoelTrejo2006}
\end{quote}

\hypertarget{motor-de-priorizaciuxf3n}{%
\subsection{Motor de priorización}\label{motor-de-priorizaciuxf3n}}

Se encarga de asignar un valor numérico a cada carril, que indica su
prioridad. Entre mayor el número, mayor la prioridad. Este número de
genera usando como base la demanda predicha, aunque también es posible
usar restricciones y reglas definidas por el \emph{Categorizador de
parámetros}.

\hypertarget{generador-de-intervalos}{%
\subsection{Generador de intervalos}\label{generador-de-intervalos}}

Usa los valores generados por el \emph{Motor de priorización} para
generar una proporción de la duración de cada fase del semáforo en la
duración total del ciclo. Posteriormente usa como base las reglas y
restricciones generados por el \emph{Categorizador de parámetros} para
generar varias propuestas de la duración total del ciclo de fases de
luces. Se obtiene como salida varios juegos de propuestas de duraciones
de fases que pueden haber tomado en cuenta diferentes reglas.

\hypertarget{constructor-de-redes-de-petri}{%
\subsection{Constructor de redes de
Petri}\label{constructor-de-redes-de-petri}}

A partir de las propuestas de intervalos generadas por el
\emph{Generador de intervalos}, se encarga de construir una red de Petri
temporizada para cada una de ellas.

\hypertarget{optimizador}{%
\subsection{Optimizador}\label{optimizador}}

Recibe múltiples propuestas de redes de Petri y a través de algoritmos
genéticos, cruza los genes de las diferentes propuestas (que tomaron en
cuenta diferente reglas para construirse) buscando maximizar los
parámetros considerados como ventajosos (como el flujo) y minimizar los
considerados como perjudiciales (como las cosas y los tiempos de
espera). La información de cuáles son estos parámetros se obtiene del
\emph{Categorizador de parámetros}. Al final da como salida una red de
Petri optimizada.

\hypertarget{controlador}{%
\subsection{Controlador}\label{controlador}}

Tiene las funciones para necesarias para leer la red de Petri
temporizada que recibe y controlar los cambios de luces según lo indique
la red.

\hypertarget{luces-de-semuxe1foro}{%
\subsection{Luces de semáforo}\label{luces-de-semuxe1foro}}

Son la manera en la que se plasman los intervalos de luces generados y
son lo que físicamente indica a los conductores cuando deben circular o
detenerse.

\hypertarget{recursos-sumo}{%
\section{Recursos: SUMO}\label{recursos-sumo}}

Para probar y desarrollar a detalle la arquitectura, es necesario contar
con un entorno de simulación versátil y altamente configurable donde
probar los algoritmos creados en base a nuestras hipótesis. El primer
acercamiento para resolver reste problema fue desarrollar desde cero un
simulador de tráfico, pero ya que esto tiene su propia complejidad y no
el objetivo final al que pretendemos llegar, buscamos otras
alternativas. De entre todas, la que parece ser la solución definitiva
es el simulador de tráfico urbano SUMO. ``\textbf{S}imulation of
\textbf{U}rban \textbf{MO}bility'' (Eclipse SUMO) es un paquete de
simulación de tráfico vial de código abierto, altamente portátil,
microscópico y continúo diseñado para manejar grandes redes viales
\textcite{SUMO2018}. Permite simular cómo una determinada demanda de
tráfico que consiste en vehículos individuales se mueve a través de una
red de carreteras determinada. La simulación permite abordar un amplio
conjunto de temas de gestión del tráfico. Es puramente microscópico:
cada vehículo está modelado explícitamente, tiene una ruta propia y se
mueve individualmente a través de la red. Las simulaciones son
deterministas por defecto, pero hay varias opciones para introducir la
aleatoriedad.

Al tratarse de un paquete, la instalación por defecto incluye varias
aplicaciones, scripts e interfaces aparte de SUMO. Estas aplicaciones se
utilizan para importar y preparar redes de carreteras, así como para
procesar datos para su uso en SUMO.

\hypertarget{caracteruxedsticas-relevantes-de-sumo-para-la-investigaciuxf3n-de-tuxe9cnicas-de-control-de-semuxe1foros.}{%
\subsection{Características relevantes de SUMO para la investigación de
técnicas de control de
semáforos.}\label{caracteruxedsticas-relevantes-de-sumo-para-la-investigaciuxf3n-de-tuxe9cnicas-de-control-de-semuxe1foros.}}

\begin{itemize}
\tightlist
\item
  Incluye todas las aplicaciones necesarias para preparar y realizar una
  simulación de tráfico
\item
  Permite simular desde una solo intersección hasta ciudades enteras
\item
  Altamente configurable a través de archivos XML
\item
  Documentación completa y actualizada de todas las características,
  interfaces y librerías que incluye, así como guías, tutoriales y
  ejemplos de configuración de gran cantidad tópicos.
\item
  Gran cantidad de tipos de vehículos disponibles, entre ellos de
  emergencia (ambulancias) y de autoridad (patrullas).
\item
  Calles de varios carriles con cambio de carril, carriles configurables
  para permitir solo el tipo de tráfico especificado.
\item
  Diferentes reglas de derecho de paso, semáforos
\item
  Incluye interfaces en Python para obtener datos de la simulación en
  tiempo real, así como para controlar aspectos de esta, como los
  semáforos.
\item
  Incluye editor gráfico de rutas y GUI para el simulador.
\item
  Velocidad de ejecución rápida (hasta 100.000 actualizaciones de
  vehículo por segundo en una máquina de 1 GHz)
\item
  Código abierto (EPL)
\end{itemize}

\hypertarget{vista-general}{%
\subsection{Vista general}\label{vista-general}}

Editor gráfico NETEDIT mostrando una inserción y el menú de edición de
semáforos.
\includegraphics[width=\textwidth]{sumo/1cb8aa292f0be15b402ccd4f098f53e0.png}

Simulando la intersección anterior de manera gráfica en SumoGui.
\includegraphics[width=\textwidth]{sumo/f06ad63e2235a639007f9748f2326f91.png}

Controlando los semáforos desde Python con TraCI (Traffic Control
Interface).
\includegraphics[width=\textwidth]{sumo/8a185a540ef5e98b250d7c70216cddfc.png}

Los diversos tipos de vehículos disponibles.
\includegraphics[width=\textwidth]{sumo/d600ef6ce1de01e90d10a436d7b6bb75.png}

\hypertarget{simulaciuxf3n-de-semuxe1foros}{%
\subsection{Simulación de
semáforos}\label{simulaciuxf3n-de-semuxe1foros}}

Los semáforos (llamados en el simulador TLS - \emph{Traffic Light
System}) se pueden crear de manera gráfica en NETDIT y automáticamente
generan un programa de control.

\includegraphics[width=\textwidth]{sumo/d53e12f08f94d08fd7e31f214786b43e.png}

\includegraphics[width=\textwidth]{sumo/e760085ba60c72e71c15ed1d0d5ab9aa.png}

\hypertarget{definiciuxf3n-de-nuevos-programas-tls}{%
\subsection{Definición de nuevos programas
TLS}\label{definiciuxf3n-de-nuevos-programas-tls}}

Se puede cargar nuevas definiciones para semáforos como parte de un
archivo adicional. La definición de un programa de semáforo dentro de un
archivo adicional se ve así: Cada programa está compuesto de varias
fases de cierta duración. En cada una, el atributo \emph{state} define
con una cadena de caracteres los colores de todos los semáforos en esa
fase. El significado de los caracteres principales se puede ver en la
siguiente tabla:

La posiciónde cada caracter en la cadena se corresponde con las
conexiones de la insercción controlada empezando desde arriba en el
orden de las manecillas del reloj. Por ejemplo, la siguiente imagen se
corresponde con la cadena \texttt{state\ =\ "GrGr"}.
\includegraphics[width=\textwidth]{sumo/tls_light_order.png}

\hypertarget{control-de-los-semuxe1foros-con-python}{%
\subsection{Control de los semáforos con
Python}\label{control-de-los-semuxe1foros-con-python}}

Más importante aún, también es posible controlar los estados de los
semáforos programáticamente a través de una interfaz incluida en el
paquete de instalación llamada TraCI.

TraCI es la abreviatura de
``~\textbf{Tra}fic~\textbf{C}ontrol~\textbf{I}nterface''.~Al dar acceso
a una simulación de tráfico en ejecución, permite recuperar valores de
objetos simulados y manipular su comportamiento ``en línea''.

TraCI utiliza una arquitectura cliente / servidor basada en TCP para
proporcionar acceso a SUMO. De este modo, SUMO actúa como servidor y el
código Python con TraCI como cliente.

A continuación, se muestra el código de ejemplo que controla la lógica
del semáforo para que se controle de la siguiente manera:

\includegraphics[width=\textwidth]{sumo/3a9d001be95c93c93c1c13ed9aeb7b26.png}

El ejemplo muestra una simple intersección de cuatro vías. Hay tráfico
normal en el eje horizontal y vehículos importantes (ambulancias,
patrullas, camiones de bomberos, etc.) en el eje vertical de norte a
sur. En la vía que viene desde el norte hay un detector para reconocer a
los vehículos que van entrando. Mientras que ningún vehículo ingresa
desde el norte, siempre damos color verde en el eje horizontal, pero
cuando un vehículo ingresa al circuito del detector, cambiamos la señal
de inmediato para que el vehículo pueda cruzar la intersección sin
detenerse.

\hypertarget{creaciuxf3n-de-simulaciuxf3n}{%
\section{Creación de simulación}\label{creaciuxf3n-de-simulaciuxf3n}}

Para probar y desarrollar a detalle la arquitectura se usará el
simulador de tráfico urbano SUMO, que incluye prácticamente todas las
herramientas necesarias.

\hypertarget{red-de-carreteras}{%
\subsection{Red de carreteras}\label{red-de-carreteras}}

El primer paso para crear una simulación en SUMO consiste en crear una
red de carreteras. Dichas redes deben estar definidas en un archivo con
extensión .net.xml que puede ser creado de múltiples maneras. Una de
ellas es utilizando la aplicación netconvert (incluida en la instalación
base), que se encarga de importar redes de carreteras de diferentes
fuentes que pueden ser usadas por otras herramientas del paquete
incluído en SUMO. También es posible utilizar la aplicación gráfica
netedit para editar una red previamente creada con netconvert o incluso
crear una desde cero con la misma aplicación.

El método usado para crear la red de carreteras que utilizará la
sumulación es una combinación de los dos anteriores. Se creó la red de
tráfico usando un script llamado
\href{https://sumo.dlr.de/docs/Tutorials/OSMWebWizard.html}{osmWebWizard},
que permite seleccionar un área geográfica real desde OpenStreetMaps y
convertirla en el red con extensión .net.xml que utiliza SUMO.

Para motivos de prueba, se usó una intersección de Mérida conocida, para
poder simular flujos a partir de lugares familiares, y en dado caso de
ser necesario recolectar datos reales. La intersección en cuestión está
ubicada en el sur de la ciudad, donde Circuito Colonias se cruza con la
calle 50.

Para corroborar que los datos generados por el script sean certeros, se
comparó la generación de la intersección con imágenes reales de Google
Maps, y hubo que ajustar el ancho del carril que corresponde a la calle
50 de uno a dos carriles (realmente tiene como 4, pero siempre hay
coches estacionados a ambos costados, al final se pueden aprovechar solo
2). Desconozco si las calles adyacentes tienen el ancho correcto, pero
considero que solo ésta afectan al objetivo de la simulación.

Los datos recuperados por osmWebWizard, a excepción al numero de
carriles de la calle 50, fueron bastante certeros, y la intersección de
interés tiene correctamente los derechos de paso del semáforo.

Una vez montada la simulación, fue necesario prepararla para manipularse
programáticamente, por lo que el semáforo a controlar se renombró a
\emph{semaforo\_circuito\_colonias} y se modificó el comportamiento de
los semáforos para que sean estáticos y solo cambien cuando se les
indique manualmente usando código.

\hypertarget{modelado-de-la-arquitectura}{%
\subsection{Modelado de la
arquitectura}\label{modelado-de-la-arquitectura}}

Con la red de tráfico lista, el objetivo es programar la arquitectura
previamente propuesta en Python, y para ello se utilizará una interfaz
para manipular la simulación en tiempo real llamada TraCI. Dicha
interfaz ya viene incluído en la instalación por defecto de SUMO.

Los primeros módulos de la arquitectura a programar son el
\emph{Observador de eventos} y el \emph{Registrador de eventos}, y para
ello se modelaron las propiedades de una intersección en clases que se
relacionan entre si.

La más básica es Edge, que es lo equivalente a una calle y contiene sus
propiedades asociadas:

\begin{itemize}
\tightlist
\item
  conection\_uses\_from: relaciona el Edge con una Conection.
\item
  conection\_uses\_to: relaciona el Edge con una Conection.
\item
  name: nombre o apodo para la calle.
\item
  num\_lanes: numero de carriles.
\item
  is\_traffic\_input: indica si el trafico entra por esta calle.
\item
  associated\_detector\_name: nombre del detector de trafico asociado a
  esta calle.
\item
  street\_name: nombre real de la calle.
\item
  aprox\_length: largo aproximado de la calle.
\item
  aprox\_total\_width: ancho aproximado de la calle completa que incluye
  a todos los carriles.
\end{itemize}

Las calles están conectadas entre si, y esta relación se representa a
través de la clase Conection, que indica una conexión simple entre Edges
(calles):

\begin{itemize}
\tightlist
\item
  intersection: relaciona que una Intersection puede tener varias
  Conections.
\item
  from\_edge: desde que calle viene el trafico.
\item
  to\_edge: hacia que calle viene el trafico.
\end{itemize}

Las calles se agrupan en intersecciones que tienen conexiones entre
ellas y posiblemente un semáforo. Esto se representa en la clase
Intersection:

\begin{itemize}
\tightlist
\item
  name: nombre o apodo para la intersección.
\item
  associated\_traffic\_light\_name: el nombre del semáforo asociado a la
  intersección.
\item
  conections: lista de todas las conexiones entre calles.
\end{itemize}

Siguiendo la arquitectura, los datos de cada intersección y del estado
de la simulación deben almacenarse en algún lugar para posteriormente
realizar un reporte que se guardará para su análisis. Se escogió medio
de almacenamiento temporal una base de datos en sqlite, y se utilizó la
librería Pony ORM para convertir el modelado en clases a tablas de una
base de datos.

Actualmente se está trabajando en la implementación del framework Flow,
que permite manipular conectar fácilmente SUMO con librerías de
Reinforcement Learning, así como incluye métodos para generar tráfico de
manera más realista.

\clearpage % Nueva página
